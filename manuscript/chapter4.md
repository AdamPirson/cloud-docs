# Создание образов Docker. Команды Dockerfile.

В предыдущей главе мы рассмотрели основные концепции и базовое устройство контейнеров (containers). Контейнеры, поддерживаемые возможностями изоляции операционной системы Linux или, чуть реже, Windows Server, способы обеспечить легкую, скоростную виртуализацию с использованием общего ядра операционной системы, и крайне эффективно разделить и изолировать вычислительные ресурсы мощного сервера или кластера, работающего в удаленном облачном центре данных. Главный инструмент для организации и запуска стандартных контейнеров - Docker.

Все зависимости контейнеров, их файлы и библиотеки, упакованы в так называемый образ (image) контейнера. Образ с определенной меткой (tag) является неизменным (immutable), и гарантирует одинаковую работу контейнера и логики приложения или сервиса внутри него при переносе и перезапуске на любых кластерах и серверах. Образы хранятся в репозитории образов, самый популярный - это официальный репозиторий Docker Hub. Все это делает контейнеры идеальным способом переноса функциональности и зависимостей сложной распределенной системы между серверами, кластерами, и провайдерами облачных вычислительных ресурсов.

Нам, как разработчикам, прежде всего интересно, как создавать новые образы контейнеров, в которых мы будем размещать свои приложения, или микросервисы, а затем запускать контейнеры из этих образов в облаке. Управлять ими, как правило, мы станем с помощью Kubernetes. Давайте займемся этим.

## Структура Dockerfile. Основные команды

Создать свои собственные образы для запуска своих команд, приложений или микросервисов с помощью Docker чрезвычайно просто. Необходимо указать перечень зависимостей, файлов, библиотек и основного, базового образа в так называемом файле `Dockerfile`. Формат так прост и популярен, что его поддержку вы найдете в любых предпочитаемых вами редакторах и IDE, иногда с использованием расширений (plugins, или extensions для VS Code).

Вот основа любого файла `Dockerfile`:

```Dockerfile
# Это комментарий
# Каждый файл Dockerfile должен начинаться с FROM
FROM [базовый_образ]

[Команда|Инструкция] [аргументы]

```

Любой новый образ должен на чем-то основываться - как мы помним, контейнер работает в общей операционной системе, имея доступ лишь к ядру, и даже простейшие консольные приложения требуют базовых библиотек для вывода данных на консоль и работы с терминалом. Базовый образ - это обычно или некий набор файлов, отвечающий дистрибутиву Linux, или чуть более расширенный набор библиотек, инструментов и зависимостей для компиляции и запуска приложений для выбранного языка. Стоит еще раз вспомнить, что все версии и названия Linux, используемые для создания образов - это просто файлы с инструментами и библиотеками. Ядро операционной системы будем общим, доступным через систему выполнения контейнеров Docker.

Именно базовый образ указывает команда `FROM`, правила выбора образа такие же, как и при запуске образа командой `docker run`. Если не указывать метку tag контейнера явно, это будет `latest`.

Следующая распространенная команда - `RUN`. Она запускает команду уже внутри контейнера. Этих двух команд вполне достаточно, чтобы создать первый собственный образ (image):

```Dockerfile
# Используем возможности Ubuntu как базовый образ
FROM ubuntu
# Любые команды Ubuntu теперь доступны для запуска RUN
# Но, они запускаются при построении образа, не для запуска контейнера
RUN echo "привет мир!" > hello_world

```

Мы сохраним этот файл в директории `dockerfile/helloworld`, и попробуем построить на его основе образ контейнера. Сделаем это команда `docker build`:

```shell
$ docker build . -t helloworld
Sending build context to Docker daemon  2.048kB
Step 1/2 : FROM ubuntu
 ---> 775349758637
Step 2/2 : RUN echo "привет мир!" > hello_world
 ---> Running in 98b510ad11b3
Removing intermediate container 98b510ad11b3
 ---> eb795c9beae9
Successfully built eb795c9beae9
Successfully tagged helloworld:latest
```

Для запуска этой команды мы перешли непосредственно в директорию, где находится наш Dockerfile, указали расположение этого файла (текущая директория `.`), и самое главное, название образа нашего контейнера (`- t helloworld`). Дополнительную версию или специальную метку (tag) мы для простоты не включили, и по умолчанию такая команда всегда будет строить образ с меткой `helloworld:latest`.

Как мы видим из напечатанного в консоли, наш новый образ создается в два этапа - сначала скачивается и используется базовый образ Ubuntu (он конечно же будет скачан только один раз, и после этого сохраняется в кэше вашей машины для ускорения процесса), а затем запускается команда, которая создает простой файл с эпохальной фразой “привет мир!”

Давайте запустим созданный собственными руками новый образ! Начнем с интерактивного режима с терминалом (`-it`) и посмотрим, что у нас есть в нашей файловой системе:

```shell
$ docker run -it helloworld
root@68ec78485349:/# ll
total 76
drwxr-xr-x   1 root root 4096 Nov  7 17:53 ./
drwxr-xr-x   1 root root 4096 Nov  7 17:53 ../
-rwxr-xr-x   1 root root    0 Nov  7 17:53 .dockerenv*
drwxr-xr-x   2 root root 4096 Oct 29 21:25 bin/
drwxr-xr-x   2 root root 4096 Apr 24  2018 boot/
drwxr-xr-x   5 root root  360 Nov  7 17:53 dev/
drwxr-xr-x   1 root root 4096 Nov  7 17:53 etc/
-rw-r--r--   1 root root   21 Nov  7 17:51 hello_world
…

root@68ec78485349:/# cat hello_world 
привет мир!
root@68ec78485349:/# exit
exit

```

Как мы видим, наш новый образ успешно запущен, контейнер работает, файловая система взята из базового образа Ubuntu, и созданный в процессе построения образа файл `hello_world` на месте и содержит именно то, что мы хотели.

Однако, если мы попробуем просто запустить контейнер, он тут же закончит свою работу:

```shell
$ docker run helloworld
$
```

Дело в том, что команда `RUN` просто исполняет указанные ей инструкции при построении образа, в нашем случае создавая файл, или запуская любые другие команды, однако после построения образа она вызываться уже не будет. 

Чтобы указать команду, которая будет выполняться после запуска контейнера из образа image, используется команда `CMD` или `ENTRYPOINT`. Добавим их и создадим новый файл `Dockerfile` в папке `helloworld-loop`. Вместо создания файла в процессе построения образа, скопируем файл и скрипт для его печати командой `COPY`.

Вот наш скрипт для печати содержимого файла в цикле:

```shell
#!/bin/bash
while true; do date; cat hello_world; sleep $1; done
``` 

Скрипт будет печатать содержимое нашего файла в цикле, добавляя текущее время, в промежутке делая паузу. Размер паузы передается в параметре. Перенесем все нужные нам зависимости внутрь нового образа:

```Dockerfile
# Используем возможности Ubuntu как базовый образ
FROM ubuntu

# Поменяем рабочую директорию на более удобную
WORKDIR /opt/helloworld

# Скопируем нужные нам для работы контейнера файлы в образ
# Обратите внимание - ./ отвечает директории, указанной командой WORKDIR
COPY hello_world ./
COPY print_loop.sh ./

# Команда CMD или ENTRYPOINT исполняется при запуске контейнера
# Сначала идет команда, затем список аргументов. У нас - длина паузы.
CMD ["/opt/helloworld/print_loop.sh", “2”]

```

Здесь у нас целая гроздь новых команд `Dockerfile`, все они, тем не менее, чрезвычайно просты и логичны:

* `WORKDIR` - меняет рабочую директорию в файловой системе контейнера. Для образности, представьте эту команду в виде обычной `mkdir`.
* `COPY` - копирует файл из директории, в который вы запустили команду `docker build`, в файловую систему контейнера. Обычно самая полезная и часто используемая команда для переноса исходного кода и библиотек в контейнер. Обратите внимание, что по умолчанию `COPY` переносит файлы в корень файловой системы, после команды `WORKDIR` - в эту новую директорию, а еще вы можете указать ей абсолютный путь файловой системы, куда следует поместить файлы.
* `CMD` (или`ENTRYPOINT`) - команда, которая будет выполняться после запуска контейнера. Основная форма - массив в квадратных скобках, где указывается команда и ее аргументы. Мы просто запустим свой shell-скрипт. Ему требуется параметр, мы его передаем в том же массиве.
Разница между командами `CMD` и `ENTRYPOINT` не так велика, основная разница в том, что аргументы для `CMD` чуть проще изменять при запуске контейнера. Детали легко найти в документации.
Есть еще один формат этих команд - исполнение напрямую оболочкой системы shell, в этом случае следует просто указать команду целиком, без массива и кавычек. Однако использованная нами только что форма записи более гибкая и обычно предпочтительнее.


Повторим построение образа `helloworld` уже на основе нашего нового `Dockerfile`, и посмотрим, что теперь получается при запуске контейнера из этого образа:

```shell
helloworld-loop$ docker build . -t helloworld
…
Step 2/5 : WORKDIR /opt/helloworld
 ---> Using cache
 ---> f35f404f3440
Step 3/5 : COPY hello_world ./
 ---> Using cache
 ---> 689899f448f4
Step 4/5 : COPY print_loop.sh ./
 ---> b04eda22b54c
Step 5/5 : CMD ["/opt/helloworld/print_loop.sh", "2"]


```

Как видно, к построению образа добавились наши новые шаги. Запустим новый контейнер:

```shell
$ docker run helloworld
Fri Nov  8 22:40:12 UTC 2019
привет мир! 
Fri Nov  8 22:40:14 UTC 2019
привет мир!
Fri Nov  8 22:40:16 UTC 2019
...

```

Теперь в нашем образе находится по большому счету настоящее приложение - оно запускается и печатает в цикле информацию. Так как наш цикл бесконечный, остановить контейнер командой терминала `exit` не получится - тут пригодятся команды `docker ps` и `stop`, которые мы как раз применяли в прошлой главе.

Только что узнанных команд на удивление хватает для построение раеальных образов контейнеров. Мы вполне можем перенести свое приложение и его ресурсы в контейнер, и запустить его при начале работы контейнера. Теперь давайте посмотрим, как создавать образы для реальных приложений и языков программирования.

## Создание образов для приложений Java, Go, Node.js

Основная задача образа контейнера image - обеспечить упаковку всех необходимых зависимостей для беспроблемного переноса запускаемого в контейнере приложения или микросервиса между любыми серверами и провайдерами облака. В случае реальных, написанных нами программ это означает, что мы должны удостовериться, что все виртуальные машины Java, зависимости скомпилированного приложения, необходимые ему ресурсы правильно сохранены в образе контейнера и смогут запускаться на любой системе, совместимой с контейнерами.

Обычная проблема при создании образа - копирование бинарного файла с программой или сервисом, не совместимым со стандартами Linux. К примеру, собрав приложение Go на своем ноутбуке Mac, вы не сможете перенести его в контейнер - внутри контейнера действуют стандарты Linux, и ваше приложение не запустится, несмотря на то, что среда запуска контейнеров (container runtime) Docker работает на том же самом ноутбуке. 

Лучшее решение в этом случае - компилировать и собирать (build) приложение как часть построения образа image, инструкциями Dockerfile. В этом случае все происходит непосредственно внутри операционного ядра контейнера, и полученный образ будет совместим с любыми стандартными средами запуска контейнеров, в том числе в коммерческих провайдерах облака.

### Java

Java - по прежнему король языков программирования, когда речь заходит о больших корпоративных системах и серверных приложениях. Ничего не мешает нам запускать сервисы, написанные на Java, внутри контейнеров Docker (кстати говоря, контейнеры в некотором роде уменьшили значимость виртуальной машины JVM и важность знаменитого слогана “написано однажды, запускается везде” - ведь сами контейнеры позволяют это сделать вообще для любого языка и библиотеки). 

Самая популярная библиотека для построения сервисов и серверных приложений - без сомнения Spring Boot, а система сборки - Maven. Давайте незамедлительно засучим рукава и в течение 10 минут упакуем сервис Java и Spring Boot в образ контейнера image, а затем запустим его.

Вот наш сервис, работающий с протоколом HTTP:

```java
package com.porty.dockerfile;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/** Простейший HTTP сервис Java с использованием Spring Boot */
@SpringBootApplication
public class HelloJavaSpringBoot {
   // запускает стандартный сервер Jetty, порт 8080
   public static void main(String[] args) {
       SpringApplication.run(HelloJavaSpringBoot.class);
   }


   @RestController
   public static final class HelloWorldController {
       // обрабатываем запрос к корневому пути /
       @GetMapping("/")
       public String helloWorld() {
           return "Привет, это Java Spring Boot из контейнера!";
       }
   }
}

```

Здесь все просто - мы используем стандартные инструменты библиотеки Spring Boot, чтобы создать приложение (`SpringApplication.run`), и обработать запросы к корневому маршруту `/`. Работать это приложение сможет на любой приличной версии Java, 8, 9, 11, 12, 13 (да, именно так, версий в Java теперь с избытком!). Располагаться этот файл для сборки проекта Maven должен в стандартной директории `src/main/java`.

Чтобы указать все необходимые нам зависимости, напишем стандартный файл сборки для инструмента Maven. Многие детали опущены, но все можно найти на GitHub в примерах книги, и тем более в любом примере Spring Boot:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project ...

<artifactId>hello-world</artifactId>
  <packaging>jar</packaging>
<name>Hello Java and SpringBoot</name>
<version>1.0.0</version>
...

<dependencies>

  <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter</artifactId>
  </dependency>
…

```

Мы указываем, что будем собирать свое приложение в виде архива JAR, назовем его `hello-world` версии `1.0.0`. Остальное указывает, какие компоненты и библиотеки Spring Boot нам понадобятся.

Это все! Мы можем собрать и запустить этот сервис, и посмотреть, как он отвечает на запросы через порт 8080 (это порт по умолчанию). Давайте теперь соберем и упакуем сервис в образ контейнера Docker. Такой стандартный и очень простой файл сборки `Dockerfile` по большому счету подойдет для большинства приложений Java:

```Dockerfile
# базовый образ - OpenJDK 11 и установленный Maven
FROM maven:3.6.2-jdk-11

# Соберем и запустим приложение в этой директории
WORKDIR /app

# Для сборки проекта Maven нужны исходные тексты программы
# и непосредственно файл сборки pom.xml
COPY pom.xml ./
COPY src/ ./src/

# Компиляция, сбока и упаковка приложения в архив JAR
RUN mvn package

# Запуск приложения виртуальной машиной Java из базового образа
CMD ["java", "-jar", "/app/target/hello-world-1.0.0.jar"]

```

Вот что мы сделали для упаковки приложения Java и Maven:

* Для начала взяли базовый образ `maven`, его легко найти на репозитории Docker Hub. Есть различные версии, мы использовали версию, основанную на версии OpenJDK 11. 
* Указали рабочую директорию (`app`) и скопировали туда файл сборки и код приложения из папки `src`. Прелесть системы Maven в том, что это все, что нам требуется, чтобы собрать практически любое приложение Java.
* Теперь, прямо в процессе построения образа нового контейнера, мы запустили компиляцию и упаковали приложение в архив JAR.
* Наконец, полученный архив запускается стандартной командой `java -jar` при старте контейнера. Плагин Spring Boot для Maven позаботится о том, чтобы все зависимости и библиотеки приложения были упакованы в один большой архив (fat jar).


Построим новый образ `java-hello`:

```shell
$ docker build . -t java-hello

Step 1/6 : FROM maven:3.6.2-jdk-11
 ---> 3b2476ab3d10
Step 2/6 : WORKDIR /app
 ---> 8ff277d1acce
Step 3/6 : COPY pom.xml ./
 ---> 96fae6707e9a
Step 4/6 : COPY src/ ./src/
 ---> 613b4042db7e
Step 5/6 : RUN mvn package
 ---> Running in 652db37dca12
[INFO] Scanning for projects...
Downloading from central: https://repo.maven.apache.org/maven2/org/springframework/boot/spring-boot-starter-parent/2.1.4.RELEASE/spring-boot-starter-parent-2.1.4.RELEASE.pom
…
[INFO] BUILD SUCCESS
…
Step 6/6 : CMD ["java", "-jar", "/app/target/hello-world-1.0.0.jar"]

```

Все шаги логичны и нам уже знакомы - но обратите внимание на то, что Maven будет заново скачивать все зависимости и библиотеки JAR из Интернета, и компилировать приложение каждый раз при построении контейнера. В этом есть плюс - это “чистая” сборка, не зависящая от кэша и состояния вашей машины. Большой минус - постоянное скачивание библиотек и долгое время сборки. Чуть позже мы увидим различные решения этой проблемы.

Давайте запустим наш контейнер - не забудьте, это серверное приложение, и надо перенаправить необходимые порты на порты локальной машины командой `-p`:

```shell
$ docker run -it -p 8080:8080 java-hello
…
2019-11-08 INFO 1 --- Starting HelloJavaSpringBoot v1.0.0
…
Jetty started on port(s) 8080 (http/1.1) with context path '/'
```

Контейнер успешно запущен из созданного нами образа, и компоненты Spring Boot запустили встроенный HTTP сервер, отвечающий по адресу 8080. Мы перенаправили этот порт на локальный, и теперь можем проверить, что отвечает наш сервис:

```shell
$ curl localhost:8080
Привет, это Java Spring Boot из контейнера!

```

Образ создан и полностью автономен и работоспособен. Для запуска нашего нового Java-сервиса не нужно больше ничего - ни установленных виртуальных машин Java определенных версий, ни настроен пути `PATH`, ни дополнительных библиотек JAR. Контейнеры сдерживают свое обещание - собранный один раз образ с сервисом или приложением теперь можем быть использован сколь угодно много раз для запуска этого сервиса на любых серверах, кластерах и других вычислительных ресурсах, не требуя никаких дополнительных настроек!

### Go


### Node.js


## Многоступенчатые образы. Размер образа контейнера


## Альтернативы Dockerfile. Jib. Buildpacks.



## Резюме


